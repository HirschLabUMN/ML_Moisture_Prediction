---
title: "Partitioning By Variables"
author: "Michael Burns"
date: "2/3/2020"
output: html_document
---

The purpose of this RMarkdown file is to figure out how to parition data by a specific variable.  Nathan Miller first told Candy and I about this, and what he suggested was to partition the data randomly (done), as well as by genotype, environment, block, etc.  If it somehow groups the data, try partitioning by it.  The hope is to find what would make the best partitioning variable when training the model.

```{r}
library(tidyverse)
library(readxl)
library(progress)
```

```{r}
full_dataset <- read_xlsx("../Data/Spectra_Data/spectra_learning_sets.xlsx")
head(full_dataset)
```


```{r by_genotype}
uniq_gt <- unique(full_dataset$Genotype) #Finding all unique genotypes
uniq_gt_sample <- sample(uniq_gt, size = 0.9*length(uniq_gt)) #Random sampling 90% of unique genotypes

gt_index <- vector() #Creating indexing vector
for(i in 1:length(uniq_gt_sample)){ #Iterates through the unique genotype samples
  gt_index <- append(gt_index, which(full_dataset$Genotype == uniq_gt_sample[i]),after = length(gt_index))
  #Appends index vector to add row indicies where genotype matches one of the selected genotypes
}

train_by_gt <- full_dataset[gt_index,] #Creates training set (based on genotype)
test_by_gt <- full_dataset[-gt_index,] #Creates testing set (based on genotype)
```

```{r}
head(train_by_gt)
head(test_by_gt)
dim(train_by_gt)
dim(test_by_gt)
```

```{r}
#####
# Creating spectra matrices
#####
training_spectra_readings<-as.matrix(train_by_gt[,c(24:164)]) #having the spectra in a matrix will allow a cleaner code when calling them as predictors.
dim(training_spectra_readings)
test_spectra_readings<-as.matrix(test_by_gt[,c(24:164)]) #having the spectra in a matrix will allow a cleaner code when calling them as predictors.
dim(test_spectra_readings)
  
#####
# Creating the model
#####
spectra_model<-plsr(train_by_gt$Moisture_Avg~training_spectra_readings, validation = "CV")
  
#####
# Choosing Components
#####
R2_Y<-R2(spectra_model, estimate = "train")
R2_Y_max<-max(R2_Y$val)
R2_Y_mincomp<-R2_Y$val<0.8*R2_Y_max
R2_Y_compnum<-sum(R2_Y_mincomp)+1

RMSEP_mod<-RMSEP(spectra_model)
RMSEP_val<-RMSEP_mod$val
RMSEP_val_CV<-RMSEP_val[c(T,F)]
RMSEP_min<-which.min(RMSEP_val_CV)-1 # -1 corrects for intercept being considered in the RMSEP values list

plot(RMSEP_mod, legendpos = "topright", 
     main = "RMSE vs Number of Components Used", 
     ylab = "RMSE",
     xlab = "Number of Components",
     sub = paste("Minimum RMSE found with", RMSEP_min, "components", sep = " "),
     col.sub = "blue")
abline(v = RMSEP_min, col = "blue")
abline(v = RMSEP_min+10, col = 'red')

plot(R2_Y, 
     main = "R^2 vs Number of Components Used", 
     ylab = "R^2",
     xlab = "Number of Components",
     sub = paste(round(0.8*R2_Y_max*100,1), "% of variation found with ", R2_Y_compnum, " components", sep = ""),
     col.sub = "blue")
abline(v = R2_Y_compnum, col = "blue")
abline(v = RMSEP_min+10, col = 'red')
  
#####
# Prediction model
#####
component_predictions_pls<-drop(predict(spectra_model, ncomp = 15, newdata = test_spectra_readings))
#component_predictions_pls_transformed<-component_predictions_pls
  
#####
# Metrics
#####
sqrt(mean((test_by_gt$Moisture_Avg-component_predictions_pls)^2))
caret::R2(component_predictions_pls, test_by_gt$Moisture_Avg)
```

```{r bootstrapping_by_genotype}
by_gt_RMSE <- vector(length = 1000)
by_gt_R2 <- vector(length = 1000)

for(a in 1:1000){
  uniq_gt_sample <- sample(uniq_gt, size = 0.9*length(uniq_gt)) #Random sampling 90% of unique genotypes

  gt_index <- vector() #Creating indexing vector
  for(i in 1:length(uniq_gt_sample)){ #Iterates through the unique genotype samples
    gt_index <- append(gt_index, which(full_dataset$Genotype == uniq_gt_sample[i]),
                       after = length(gt_index))
  #Appends index vector to add row indicies where genotype matches one of the selected genotypes
  }

  train_by_gt <- full_dataset[gt_index,] #Creates training set (based on genotype)
  test_by_gt <- full_dataset[-gt_index,] #Creates testing set (based on genotype)
  
  #####
  # Creating spectra matrices
  #####
  training_spectra_readings<-as.matrix(train_by_gt[,c(24:164)]) #having the spectra in a matrix will allow   a cleaner code when calling them as predictors.
  dim(training_spectra_readings)
  test_spectra_readings<-as.matrix(test_by_gt[,c(24:164)]) #having the spectra in a matrix will allow a   cleaner code when calling them as predictors.
  dim(test_spectra_readings)
  
  #####
  # Creating the model
  #####
  spectra_model<-plsr(train_by_gt$Moisture_Avg~training_spectra_readings, validation = "CV")
  
  #####
  # Prediction model
  #####
  component_predictions_pls<-drop(predict(spectra_model, ncomp = 15, newdata = test_spectra_readings))
  #component_predictions_pls_transformed<-component_predictions_pls
  
  #####
  # Metrics
  #####
  by_gt_RMSE[a] <- sqrt(mean((test_by_gt$Moisture_Avg-component_predictions_pls)^2))
  by_gt_R2[a] <- caret::R2(component_predictions_pls, test_by_gt$Moisture_Avg)
  

  
}

print('RMSE:')
mean(by_gt_RMSE)
sd(by_gt_RMSE)

print('R^2:')
mean(by_gt_R2)
sd(by_gt_R2)

```

```{r partition_by_function}
dataset <- full_dataset
column_number <- 2


partitioning_groups_analysis <- function(dataset, column_number, iterations = 1000){
  group_RMSE <- vector(length = iterations)
  group_R2 <- vector(length = iterations)
  uniq_group <- unique(dataset[[column_number]])
  cat("Partioning Column: ",colnames(dataset[,column_number]), sep = "")
  pb <- progress_bar$new(total = iterations)
  for(a in 1:iterations){
    uniq_group_sample <- sample(uniq_group, size = 0.9*length(uniq_group)) #Random sampling 90% of unique   genotypes

    group_index <- vector() #Creating indexing vector
    for(i in 1:length(uniq_group_sample)){ #Iterates through the unique genotype samples
      group_index <- append(group_index, which(dataset[,column_number] == uniq_group_sample[i]),
                        after = length(group_index))
    #Appends index vector to add row indicies where genotype matches one of the selected genotypes
    }

    train_by_group <- dataset[group_index,] #Creates training set (based on genotype)
    test_by_group <- dataset[-group_index,] #Creates testing set (based on genotype)
  
    #####
    # Creating spectra matrices
    #####
    training_spectra_readings<-as.matrix(train_by_group[,c(24:164)]) #having the spectra in a matrix will        allow   a cleaner code when calling them as predictors.
    dim(training_spectra_readings)
    test_spectra_readings<-as.matrix(test_by_group[,c(24:164)]) #having the spectra in a matrix will allow       a cleaner code when calling them as predictors.
    dim(test_spectra_readings)
  
    #####
    # Creating the model
    #####
    spectra_model<-plsr(train_by_group$Moisture_Avg~training_spectra_readings, validation = "CV")
  
    #####
    # Prediction model
    #####
    component_predictions_pls<-drop(predict(spectra_model, ncomp = 15, newdata = test_spectra_readings))
    #component_predictions_pls_transformed<-component_predictions_pls
  
    #####
    # Metrics
    #####
    group_RMSE[a] <- sqrt(mean((test_by_group$Moisture_Avg-component_predictions_pls)^2))
    group_R2[a] <- caret::R2(component_predictions_pls, test_by_group$Moisture_Avg)
    pb$tick()
  }
  sink(file = paste("../Spectra/Results/partitioned_by_", 
                    colnames(dataset[,column_number]),"_RMSE_results.txt"))
  cat("\nMean:\n", mean(group_RMSE),"\n")
  cat("\nMedian:\n", median(group_RMSE), "\n")
  cat("\nStandard Deviation:\n", sd(group_RMSE), "\n")
  sink() 
  closeAllConnections()

  sink(file = paste("../Spectra/Results/partitioned_by_", 
                    colnames(dataset[,column_number]),"_R2_results.txt"))
  cat("\nMean:\n", mean(group_R2),"\n")
  cat("\nMedian:\n", median(group_R2), "\n")
  cat("\nStandard Deviation:\n", sd(group_R2), "\n")
  sink() 
  closeAllConnections()
}
```

```{r}
partitioning_groups_analysis(full_dataset,6,1000)
```

Based on these partitions, it is still best to partition the data randomly.  This increases the R^2 value from about 0.54 to 0.61.





