---
title: "Trait_Simulator"
author: "Michael Burns"
date: "11/7/2019"
output: html_document
---

This document is to simulate numerous individuals with a varying combinations of trait values.  In theory we should end with a matrix of length d^t where d is the number of divisions per trait and t is the number of traits.  For example with 5 traits and 20 divisions, we should generate 20^5 individuals.  Each individual should also be different by a small amount from the ones around it.  The first individual should be minimum values for all traits, the second one should increase one trait by one increment, and keep all others the same, etc.

```{r}
yc_data<-read.csv("/Users/michael/Desktop/Grad_School/Research/Datasets/Machine Learning/YC_final.csv")
head(yc_data)
```

```{r}
yc_outlier_rm_3<-function(data_w_outlier){
  yc_inliers<-na.omit(data_w_outlier)
  yc_keep<-vector(length = length(yc_inliers[,1]))
  for(q in 1:ncol(yc_inliers)){
    yc_mean<-mean(yc_inliers[,q])
    yc_sd<-sd(yc_inliers[,q])
    for(n in 1:length(yc_inliers[,1])){
      if(yc_inliers[n,q]>(yc_mean-(3*yc_sd)) & yc_inliers[n,q]<(yc_mean+(3*yc_sd)) & yc_inliers[n,q]>0){
        yc_inliers[n,q]<-yc_inliers[n,q]
      }else{yc_inliers[n,q]<-NA}
    }
  }
  yc_inliers
}
```
 & yc_inliers[n,q]>0

```{r}
yc_data_sub<-yc_data[17:23]
yc_data_clean<-yc_outlier_rm_3(yc_data_sub)
yc_data_clean<-na.omit(yc_data_clean)
head(yc_data_clean)
summary(yc_data_clean)
```

```{r}
Ash_values<-seq(min(na.omit(yc_data_clean$Ash_As_is)),max(na.omit(yc_data_clean$Ash_As_is)),((max(na.omit(yc_data_clean$Ash_As_is))-min(na.omit(yc_data_clean$Ash_As_is)))/19))

Fiber_values<-seq(min(na.omit(yc_data_clean$Fiber_As_is)),max(na.omit(yc_data_clean$Fiber_As_is)),((max(na.omit(yc_data_clean$Fiber_As_is))-min(na.omit(yc_data_clean$Fiber_As_is)))/19))

Protein_values<-seq(min(na.omit(yc_data_clean$Protein_As_is)),max(na.omit(yc_data_clean$Protein_As_is)),((max(na.omit(yc_data_clean$Protein_As_is))-min(na.omit(yc_data_clean$Protein_As_is)))/19))

Starch_values<-seq(min(na.omit(yc_data_clean$Starch_As_is)),max(na.omit(yc_data_clean$Starch_As_is)),((max(na.omit(yc_data_clean$Starch_As_is))-min(na.omit(yc_data_clean$Starch_As_is)))/19))

Fat_values<-seq(min(na.omit(yc_data_clean$Fat_As_is)),max(na.omit(yc_data_clean$Fat_As_is)),((max(na.omit(yc_data_clean$Fat_As_is))-min(na.omit(yc_data_clean$Fat_As_is)))/19))
```

```{r}
value_matrix<-matrix(ncol = 5, nrow = 20)
value_matrix[,1]<-Protein_values
value_matrix[,2]<-Fat_values
value_matrix[,3]<-Fiber_values
value_matrix[,4]<-Ash_values
value_matrix[,5]<-Starch_values
colnames(value_matrix)<-c("Protein","Fat","Fiber","Ash","Starch")
value_matrix
```

Here are all of the numbers, so I should be able to run a nested for loop to basically run through a column while keeping everything else constant, and then move on to the next column.  I may need more than just two loops though as I will be trying to every possible combination, and a double for loop might be difficult to use to get all of the combinations we are looking for.  Not really sure how to describe it without pictures.

```{r}
simulation_df<-expand.grid(value_matrix[,1],value_matrix[,2],value_matrix[,3],value_matrix[,4],value_matrix[,5])
names(simulation_df)<-c("Protein","Fat","Fiber","Ash","Starch")
indiv_vec<-c(1:length(simulation_df[,1]))
simulation_df$Individual<-indiv_vec
sim_df_complete<-simulation_df[c(6,1:5)]

head(sim_df_complete)
tail(sim_df_complete)

#write.csv(sim_df_complete, file = "/Users/michael/Desktop/Grad_School/Research/Datasets/Machine Learning/simulated_traits_20.csv")
```

___
___
___

Similuated traits have been run through a preliminary round of machine learning using the matlab app "Regression Learner".  This is by no means an end-all-be-all prediction sheet.  It was an attempt to create predictions based on a ML model.
For a walkthrough on how this works, please see: Machine_Learning/matlab_ml_walkthrough

```{r}
sim_trait_pred<-read.csv("/Users/michael/Desktop/Grad_School/Research/Datasets/Machine Learning/SimTraits_Predictions_1.csv")
head(sim_trait_pred)
```

Lets take a look at some of the correlations, distributions, and any other graphs I can think to make.  To do this even somewhat efficiently, we will want to just take a sample of the 3.2million sample dataset.
```{r}
library(ggplot2)
sim_pred_samp_index<-sample(sim_trait_pred$Individual, 10000)
sim_pred_samp<-sim_trait_pred[sim_pred_samp_index,]
library(dplyr)
```

```{r}
hist(sim_pred_samp$Moisture_Pred)
for(i in 2:6){
  plot<-ggplot(data = sim_pred_samp)+
    geom_point(aes(sim_pred_samp[,i],Moisture_Pred))+
    xlab(names(sim_pred_samp[i]))+
    ylab("Moisture_Pred")
  print(plot)
}
i = 4
m = 4
mean_data<-matrix(ncol = 5, nrow = 20)
for(i in 2:6){
  for(m in 1:20){
    dataset<-filter(sim_pred_samp, round(sim_pred_samp[,i],2) == round(value_matrix[m,(i-1)],2))
    mean_data[m,(i-1)]<-mean(dataset$Moisture_Pred)
  }
}


cook_comps<-as.matrix(sim_pred_samp[,c(2:7)])
cor_table_p<-Hmisc::rcorr(na.omit(cook_comps))$P
cor_table<-cor(na.omit(cook_comps))
cor_table[lower.tri(cor_table, diag = T)]<-0
cor_table_p[upper.tri(cor_table_p, diag = T)]<-0
actual_cor_table<-cor_table+cor_table_p
round(actual_cor_table,3)
```
Tried changing alpha to see if there were any patterns.  Even at alpha = 0.000000001, there was next to no difference besides a few points along the edge that looked soft.


Creating a graph with shaded regions for each trait to show overlap.
```{r}

```



